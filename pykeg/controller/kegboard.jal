-- kegboard jal source v10
-- (c) mike wakerly 2003-2006
-- http://hoho.com/mike/kegbot

include 16f628_20
include jdelay
include jascii

pragma target fuses       0x3F22
-- --------------------------------------------------------------------
-- word  cpd lvp boden mclr pwrt wdt osc         observation
-- 3FC1  off on  on    io   off  off xt
-- 3FD0  off on  on    io   off  off intrc+io
-- 3FF0  off on  on    mclr off  off intrc+io
-- 3F22  off off off   mclr off  off hs
-- 3F62  off off on    mclr off  off hs          default
-- -----------------------------------------------------------

-- -----------------------------------------------------------------------------
-- rs232 hardware setup and include
-- -----------------------------------------------------------------------------
const usart_asynch = true      -- true = RS232, false = SPI
const baudrate     = 115_200
include rs232_hw

-- -----------------------------------------------------------------------------
-- 1wire setup and include
-- -----------------------------------------------------------------------------
-- a0 = real pin, a3= debug pin
var volatile bit _1w_dq is pin_a2
var volatile bit _1w_dq_dir is pin_a2_direction
include 1wire


-- -----------------------------------------------------------------------------
-- hardware configuration
-- -----------------------------------------------------------------------------
var volatile bit rly0_pin is pin_b4
var volatile bit rly0_pin_direction is pin_b4_direction

var volatile bit rly1_pin is pin_b5
var volatile bit rly1_pin_direction is pin_b5_direction

var volatile bit led0_pin is pin_a4
var volatile bit led0_pin_direction is pin_a4_direction

-- -----------------------------------------------------------------------------
-- aliases for pic registers
-- -----------------------------------------------------------------------------
var volatile byte CMCON is f877_adcon0
var volatile byte CCP1CON is f877_ccp1con

var volatile bit  CCP1IF  at f877_pir1 : 2
var volatile bit  _CCP1IE at f877_pie1 : 2

-- -----------------------------------------------------------------------------
-- CONTROL COMMANDS
-- -----------------------------------------------------------------------------
const byte CMD_STATUS      = 0x81 -- just send the current status
const byte CMD_VALVEON     = 0x83 -- enable solenoid valve
const byte CMD_VALVEOFF    = 0x84 -- disable solenoid valve
const byte CMD_PUSHTICKS   = 0x87 -- enable pushing of ticks
const byte CMD_NOPUSHTICKS = 0x88 -- disable pushing of ticks
const byte CMD_FRIDGEON    = 0x90 -- enable the freezer relay
const byte CMD_FRIDGEOFF   = 0x91 -- disable the freezer relay
const byte CMD_READTEMP    = 0x93 -- unused, yet

-- -----------------------------------------------------------------------------
-- FRAMING CONSTANTS
-- -----------------------------------------------------------------------------
const byte CMD_START_0 = "M"
const byte CMD_START_1 = ":"
const byte CMD_END_0 = ASCII_CR   -- "\r"
const byte CMD_END_1 = ASCII_LF   -- "\n"

-- -----------------------------------------------------------------------------
-- PACKET TYPES
-- -----------------------------------------------------------------------------
const byte PKT_TYPE_STATUS = 0x01 -- a status packet

-- -----------------------------------------------------------------------------
-- INITIAL PIN STATE
-- -----------------------------------------------------------------------------
; port_a_direction = all_output

-- valve output pins
rly0_pin_direction = output
rly1_pin_direction = output

-- configure ccp input
pin_b3_direction = input

-- -----------------------------------------------------------------------------
-- INTERRUPT & IO CONFIG
-- -----------------------------------------------------------------------------
-- set port a to normal digital i/o
CMCON = 0x07

-- first 4:  dont care
-- second 4: capture mode:
-- 0100: every falling edge
-- 0101: every rising edge
-- 0110: every 4th rising edge
-- 0111: every 16th rising edge
CCP1CON = 0b_0000_0101

-- given 2200 pulses/liter,
-- on 0110, every bit == 1/550th Liter;
-- every flow_high bit == 256/550 Liter

-- -----------------------------------------------------------------------------
-- VARIABLES
-- -----------------------------------------------------------------------------
var byte flow_low = 0
var byte flow_high = 0
var volatile byte counter_low = 0
var volatile byte counter_mid = 0
var volatile byte counter_high = 0

-- -----------------------------------------------------------------------------
-- PULSE COUNTER ISR
-- -----------------------------------------------------------------------------
procedure ISR is
  pragma interrupt
  ;bank_0
  if CCP1IF == high then CCP1IF = low
    flow_low = flow_low + 1
    if flow_low == 0 then
      flow_high = flow_high + 1
    end if
  end if
end procedure

-- -----------------------------------------------------------------------------
-- INTERRUPT CONFIG
-- -----------------------------------------------------------------------------
bank_1
intcon_gie   = high         -- enable global interrupts
intcon_rbie  = low          -- DISABLE interrupts on change
intcon_t0ie  = low          -- DISABLE tmr0 interrupts
intcon_inte  = low          -- disable external interrupt (on rb0)
intcon_intf  = low          -- clear INT flag
intcon_peie  = high         -- enable perhipheral interrupt (ccp)
_CCP1IE      = high         -- enable ccp interrupt
;intcon_eeie = high         -- RISING EDGE triggered
bank_0

-- disable the solenoid
rly0_pin = off
rly1_pin = off

-- -----------------------------------------------------------------------------
-- procedures
-- -----------------------------------------------------------------------------
function ow_reset return byte is
  var byte temp = 1
  while (temp != 0) loop
    temp = _1w_reset
  end loop
end function


procedure read_temp(byte out ls, byte out ms) is begin
  _1w_writebyte(0xCC)         -- Skip ROM
  _1w_writebyte(0x44)         -- Convert T
  _1w_waitconv                -- Conversion delay
  _1w_reset                   -- Reset
  _1w_writebyte(0xCC)         -- Skip ROM
  _1w_writebyte(0xBE)         -- Read ScratchPad
  ls = _1w_readbyte
  ms = _1w_readbyte
  ow_reset
end procedure

procedure asynch_send_bit(bit in b) is begin
  -- convert a bit to a byte
  if b then
     asynch_send_hw( 1 )
  else
     asynch_send_hw( 0 )
  end if
end procedure

function byte_div_10(byte in b) return byte is begin
   var byte ret = 0
   var byte tmp = b
   tmp = tmp - 10
   while tmp <= b loop
      ret = ret + 1
      tmp = tmp - 10
   end loop
   return ret
end function

function byte_div_100(byte in b) return byte is begin
   if b >= 200 then
      return 2
   elsif b >= 100 then
      return 1
   else
      return 0
   end if
end function

procedure byte_to_dec(byte in b, byte out x, byte out y, byte out z) is begin
   var byte tmp = b

   x = byte_div_100(b)

   for x loop
      tmp = tmp - 100
   end loop
   y = byte_div_10(tmp)

   for y loop
      tmp = tmp - 10
   end loop
   z = tmp
end procedure

procedure int_to_ascii(byte in out b) is begin
   b = b + 0x30
end procedure

procedure asynch_send_ascii(byte in b) is begin
   var byte x
   var byte y
   var byte z
   byte_to_dec(b,x,y,z)
   int_to_ascii(x)
   int_to_ascii(y)
   int_to_ascii(z)
   asynch_send_hw(x)
   asynch_send_hw(y)
   asynch_send_hw(z)
end procedure

-- -----------------------------------------------------------------------------
-- STARTUP/SELF-TEST
-- -----------------------------------------------------------------------------

-- led0_pin = on
-- delay_1s()
-- led0_pin = off
-- delay_1s()
-- led0_pin = on
-- delay_1s()
-- led0_pin = off
-- delay_1s()

-- -----------------------------------------------------------------------------
-- MAIN LOOP
-- -----------------------------------------------------------------------------

var byte chr
var byte lstemp       = 0xff
var byte mstemp       = 0xff
var byte loop_count   = 0
var byte status_count = 0
var byte tmp_low      = 0
var byte tmp_high     = 0

var bit sendstatus = high

forever loop
  -- handle serial events
  if asynch_read_hw(chr) & high then
    sendstatus = high
    if chr == CMD_STATUS then
      sendstatus = high -- redundant
    elsif chr == CMD_VALVEON then
      rly0_pin = high
    elsif chr == CMD_VALVEOFF then
      rly0_pin = low
    elsif chr == CMD_FRIDGEON then
      rly1_pin = high
    elsif chr == CMD_FRIDGEOFF then
      rly1_pin = low
    elsif chr == CMD_READTEMP then
      read_temp(lstemp, mstemp)
    else
      sendstatus = low
    end if
  end if

  -- read temperature approx once every 5s
  if loop_count == 0 then
     -- but only if valve is not enabled (too intrusive)
      if rly0_pin == low then
         read_temp(lstemp, mstemp)
      end if
  end if
  loop_count = loop_count + 1

  -- send status ~1x/second in idle mode
  if status_count == 50 then
     sendstatus = high
     status_count = 0
  end if

  -- send status ~5x/second if valve pouring
  if rly0_pin == high then
     if status_count == 10 then
        sendstatus = high
        status_count = 0
     end if
  end if
  status_count = status_count + 1

  if sendstatus == high then
    sendstatus = low
    -- disable interrupts
    -- GIE = low
    tmp_low = flow_low
    flow_low = 0
    tmp_high = flow_high
    flow_high = 0
    -- GIE = high

    asynch_send_hw( CMD_START_0 )
    asynch_send_hw( CMD_START_1 )

    asynch_send_hw( PKT_TYPE_STATUS )
    asynch_send_bit( rly1_pin )
    asynch_send_bit( rly0_pin )
    asynch_send_hw( tmp_high )
    asynch_send_hw( tmp_low )
    asynch_send_hw( mstemp )
    asynch_send_hw( lstemp )

    asynch_send_hw( CMD_END_0 )
    asynch_send_hw( CMD_END_1 )
    flow_low = 0
    flow_high = 0
  end if
  delay_10ms(2)

end loop

