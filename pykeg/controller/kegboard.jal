-- kegboard jal source v10
-- (c) mike wakerly 2003-2006
-- http://hoho.com/mike/kegbot

include 16f628_20
include jdelay
include jascii

pragma target fuses       0x3F22
-- --------------------------------------------------------------------
-- word  cpd lvp boden mclr pwrt wdt osc         observation
-- 3FC1  off on  on    io   off  off xt
-- 3FD0  off on  on    io   off  off intrc+io
-- 3FF0  off on  on    mclr off  off intrc+io
-- 3F22  off off off   mclr off  off hs
-- 3F62  off off on    mclr off  off hs          default
-- -----------------------------------------------------------

-- -----------------------------------------------------------------------------
-- rs232 hardware setup and include
-- -----------------------------------------------------------------------------
const usart_asynch = true      -- true = RS232, false = SPI
const baudrate     = 115_200
include rs232_hw

-- -----------------------------------------------------------------------------
-- 1wire setup and include
-- -----------------------------------------------------------------------------
-- a0 = real pin, a3= debug pin
var volatile bit _1w_dq is pin_a2
var volatile bit _1w_dq_dir is pin_a2_direction
include 1wire


-- -----------------------------------------------------------------------------
-- hardware configuration
-- -----------------------------------------------------------------------------
var volatile bit rly0_pin is pin_b4
var volatile bit rly0_pin_direction is pin_b4_direction

var volatile bit rly1_pin is pin_b5
var volatile bit rly1_pin_direction is pin_b5_direction

var volatile bit led0_pin is pin_a4
var volatile bit led0_pin_direction is pin_a4_direction

-- -----------------------------------------------------------------------------
-- aliases for pic registers
-- -----------------------------------------------------------------------------
var volatile byte CMCON is f877_adcon0
var volatile byte CCP1CON is f877_ccp1con

var volatile bit  CCP1IF  at f877_pir1 : 2
var volatile bit  _CCP1IE at f877_pie1 : 2

-- -----------------------------------------------------------------------------
-- CONTROL COMMANDS
-- -----------------------------------------------------------------------------
const byte CMD_STATUS      = 0x81 -- just send the current status
const byte CMD_VALVEON     = 0x83 -- enable solenoid valve
const byte CMD_VALVEOFF    = 0x84 -- disable solenoid valve
const byte CMD_PUSHTICKS   = 0x87 -- enable pushing of ticks
const byte CMD_NOPUSHTICKS = 0x88 -- disable pushing of ticks
const byte CMD_FRIDGEON    = 0x90 -- enable the freezer relay
const byte CMD_FRIDGEOFF   = 0x91 -- disable the freezer relay
const byte CMD_READTEMP    = 0x93 -- unused, yet

-- -----------------------------------------------------------------------------
-- FRAMING CONSTANTS
-- -----------------------------------------------------------------------------
const byte CMD_START_0 = "M"
const byte CMD_START_1 = ":"
const byte CMD_END_0 = ASCII_CR   -- "\r"
const byte CMD_END_1 = ASCII_LF   -- "\n"

-- -----------------------------------------------------------------------------
-- PACKET TYPES
-- -----------------------------------------------------------------------------
const byte PKT_TYPE_STATUS = 0x01 -- a status packet

-- -----------------------------------------------------------------------------
-- INITIAL PIN STATE
-- -----------------------------------------------------------------------------
; port_a_direction = all_output

-- valve output pins
rly0_pin_direction = output
rly1_pin_direction = output

-- configure ccp input
pin_b3_direction = input

-- -----------------------------------------------------------------------------
-- INTERRUPT & IO CONFIG
-- -----------------------------------------------------------------------------
-- set port a to normal digital i/o
CMCON = 0x07

-- first 4:  dont care
-- second 4: capture mode:
-- 0100: every falling edge
-- 0101: every rising edge
-- 0110: every 4th rising edge
-- 0111: every 16th rising edge
CCP1CON = 0b_0000_0101

-- given 2200 pulses/liter,
-- on 0110, every bit == 1/550th Liter;
-- every flow_high bit == 256/550 Liter

-- -----------------------------------------------------------------------------
-- VARIABLES
-- -----------------------------------------------------------------------------
var byte flow_low = 0
var byte flow_high = 0
var volatile byte counter_low = 0
var volatile byte counter_mid = 0
var volatile byte counter_high = 0

-- -----------------------------------------------------------------------------
-- PULSE COUNTER ISR
-- -----------------------------------------------------------------------------
procedure ISR is
  pragma interrupt
  ;bank_0
  if CCP1IF == high then CCP1IF = low
    flow_low = flow_low + 1
    if flow_low == 0 then
      flow_high = flow_high + 1
    end if
  end if
end procedure

-- -----------------------------------------------------------------------------
-- INTERRUPT CONFIG
-- -----------------------------------------------------------------------------
bank_1
intcon_gie   = high         -- enable global interrupts
intcon_rbie  = low          -- DISABLE interrupts on change
intcon_t0ie  = low          -- DISABLE tmr0 interrupts
intcon_inte  = low          -- disable external interrupt (on rb0)
intcon_intf  = low          -- clear INT flag
intcon_peie  = high         -- enable perhipheral interrupt (ccp)
_CCP1IE      = high         -- enable ccp interrupt
;intcon_eeie = high         -- RISING EDGE triggered
bank_0

-- disable the solenoid
rly0_pin = off
rly1_pin = off

-- -----------------------------------------------------------------------------
-- procedures
-- -----------------------------------------------------------------------------
function ow_reset return byte is
  var byte temp = 1
  while (temp != 0) loop
    temp = _1w_reset
  end loop
end function


procedure read_temp(byte out ls, byte out ms) is begin
  _1w_writebyte(0xCC)         -- Skip ROM
  _1w_writebyte(0x44)         -- Convert T
  _1w_waitconv                -- Conversion delay
  _1w_reset                   -- Reset
  _1w_writebyte(0xCC)         -- Skip ROM
  _1w_writebyte(0xBE)         -- Read ScratchPad
  ls = _1w_readbyte
  ms = _1w_readbyte
  ow_reset
end procedure

-- -----------------------------------------------------------------------------
-- STARTUP/SELF-TEST
-- -----------------------------------------------------------------------------

-- led0_pin = on
-- delay_1s()
-- led0_pin = off
-- delay_1s()
-- led0_pin = on
-- delay_1s()
-- led0_pin = off
-- delay_1s()

-- -----------------------------------------------------------------------------
-- MAIN LOOP
-- -----------------------------------------------------------------------------

var byte x
var byte lstemp = 0xff
var byte mstemp = 0xff
var byte loop_count = 0
var byte fridgestatus = 2
var byte valvestatus = 0
var byte tmp_low = 0
var byte tmp_high = 0
var bit sendstatus = high

forever loop
  -- handle serial events
  if asynch_read_hw(x) & high then
    -- assume we have a known command, so send the status afterward (clear
    -- in catch-all else block at bottom)
    sendstatus = high
    if x == CMD_STATUS then
      sendstatus = high -- redundant
    elsif x == CMD_VALVEON then
      valvestatus = 1
      rly0_pin = high
    elsif x == CMD_VALVEOFF then
      valvestatus = 0
      rly0_pin = low
    elsif x == CMD_FRIDGEON then
      rly1_pin = high
      fridgestatus = 1
    elsif x == CMD_FRIDGEOFF then
      rly1_pin = low
      fridgestatus = 0
    elsif x == CMD_READTEMP then
      read_temp(lstemp, mstemp)
    else
      sendstatus = low
    end if
  end if

  -- read temperature approx once every 5s
  if loop_count == 0 then
      read_temp(lstemp, mstemp)
  end if
  loop_count = loop_count + 1

  if sendstatus == high then
    sendstatus = low
    -- disable interrupts
    -- GIE = low
    tmp_low = flow_low
    flow_low = 0
    tmp_high = flow_high
    flow_high = 0
    -- GIE = high

    asynch_send_hw( CMD_START_0 )
    asynch_send_hw( CMD_START_1 )

    asynch_send_hw( PKT_TYPE_STATUS )
    asynch_send_hw( fridgestatus )
    asynch_send_hw( valvestatus )
    asynch_send_hw( tmp_high )
    asynch_send_hw( tmp_low )
    asynch_send_hw( mstemp )
    asynch_send_hw( lstemp )

    asynch_send_hw( CMD_END_0 )
    asynch_send_hw( CMD_END_1 )
    flow_low = 0
    flow_high = 0
  else
     delay_10ms(2)
  end if

end loop

